<html>
<head>

<script id='vertex' type='x-shader/x-vertex'>
attribute vec2 aCoord;
varying vec2 surfacePosition;

void main() {
    gl_Position = vec4(aCoord.x, aCoord.y, 0.0, 1.0);
    surfacePosition = aCoord;
}
</script>


<!-- http://glsl.heroku.com/e#19291.0 -->
<script id='19291.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// a raymarching experiment by kabuto


const int MAXITER = 80;

vec3 field(vec3 p) {
        p *= .1;
        float f = .1;
        for (int i = 0; i < 5; i++) {
                p = p.yzx*mat3(.8,.6,0,-.6,.8,0,0,0,1);
                p += vec3(.123,.456,.789)*float(i);
                p = abs(fract(p)-.5);
                p *= 2.0;
                f *= 2.0;
        }
        p *= p;
        return sqrt(p+p.yzx)/f-.002;
}

void main( void ) {
        vec3 dir = normalize(vec3((gl_FragCoord.xy-resolution*.5)/resolution.x,1.));
        vec3 pos = vec3(mouse+.5,time);
        vec3 color = vec3(0);
        for (int i = 0; i < MAXITER; i++) {
                vec3 f2 = field(pos);
                float f = min(min(f2.x,f2.y),f2.z);
                
                pos += dir*f;
                color += float(MAXITER-i)/(f2+.001);
        }
        vec3 color3 = vec3(.17/(color*(.09/float(MAXITER*MAXITER))));
        color3 *= color3;
        gl_FragColor = 1.0 - vec4(color3.zyx,0.);
}
</script>

<!-- http://glsl.heroku.com/e#18918.0 -->
<script id='18918.0' type='x-shader/x-fragment'>
// Tenjix

#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.1415926535897932384626433832795

uniform float time;
uniform vec2 resolution;

const float position = 1.0;
const float scale = 1.0;
const float intensity = 1.0;

varying vec2 surfacePosition;

float band(vec2 pos, float amplitude, float frequency) {
        float wave = scale * amplitude * sin(2.0 * PI * frequency * pos.x + time) / 2.05;
        float light = clamp(amplitude * frequency * 0.002, 0.001 + 0.001 / scale, 5.0) * scale / abs(wave - pos.y);
        return light;
}

void main( void ) {

        vec3 color = vec3(0.15, 0.5, 1.0);
        color = color == vec3(0.0)? vec3(0.5, 0.5, 1.0) : color;
        vec2 pos = surfacePosition;//(gl_FragCoord.xy / resolution.xy);
        //pos.y += - 0.5 - position;
        
        // +pk
        float spectrum = 0.0;
        const float lim = 128.;
        #define time time*0.037 + pos.x*10.
        for(float i = 0.; i < lim; i++){
                spectrum += band(pos, 1.0*sin(time*0.1), 1.0*sin(time*i/lim))/pow(lim, 0.25);
        }
        
        spectrum += band(pos, 0.7, 2.5);
        spectrum += band(pos, 0.4, 2.0);
        spectrum += band(pos, 0.05, 4.5);
        spectrum += band(pos, 0.1, 7.0);
        spectrum += band(pos, 0.1, 1.0);
        
        gl_FragColor = vec4(color * spectrum, spectrum);
        
}
</script>

<!-- http://glsl.heroku.com/e#18922.0 -->
<script id='18922.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

vec2 rotate(vec2 p, float a)
        {
        return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
        }
float box(vec2 p, vec2 b, float r)
        {
        return length(max(abs(p) - b, 0.0)) - (r * 2.0);
        }

vec3 intersect(in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v)
        {
        vec3 q = o - c;
        return vec3(
        dot(cross(u, v), q),
        dot(cross(q, u), d),
        dot(cross(v, q), d)) / dot(cross(v, u), d);
        }

float rand11(float p)
        {
        return fract(sin(p * 591.32) * 43758.5357);
        }
float rand12(vec2 p)
        {
        return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5357);
        }
vec2 rand21(float p)
        {
        return fract(vec2(sin(p * 591.32), cos(p * 391.32)));
        }

vec2 rand22(in vec2 p)
        {
        return fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));
        }

float noise11(float p)
        {
        float fl = floor(p);
        return mix(rand11(fl), rand11(fl + 1.0), fract(p));//smoothstep(0.0, 1.0, fract(p)));
        }
float fbm11(float p)
        {
        return noise11(p) * 0.5 + noise11(p * 2.0) * 0.25 + noise11(p * 5.0) * 0.125;
        }
vec3 noise31(float p)
        {
        return vec3(noise11(p), noise11(p + 18.952), noise11(p - 11.372)) * 2.0 - 1.0;
        }

float sky(vec3 p)
        {
        float a = atan(p.x, p.z);
        float t = time * 0.1;
        float v = rand11(floor(a * 4.0 + t)) * 0.5 + rand11(floor(a * 8.0 - t)) * 0.25 + rand11(floor(a * 16.0 + t)) * 0.125;
        return v;
        }

vec3 voronoi(in vec2 x)
        {
        vec2 n = floor(x); // grid cell id
        vec2 f = fract(x); // grid internal position
        vec2 mg; // shortest distance...
        vec2 mr; // ..and second shortest distance
        float md = 5.0, md2 = 1.0;
        for(int j = -1; j <= 1; j ++)
                {
                for(int i = -1; i <= 1; i ++)
                        {
                        vec2 g = vec2(float(i), float(j)); // cell id
                        vec2 o = rand22(n + g); // offset to edge point
                        vec2 r = g + o - f;
                        
                        float d = max(abs(r.x), abs(r.y)); // distance to the edge
                        
                        if(d < md)
                                {
                                md2 = md; md = d; mr = r; mg = g;
                                }
                        else if(d < md2)
                                {
                                md2 = d;
                                }
                        }
                }
        return vec3(n + mg, md2 - md);
        }

#define A2V(a) vec2(sin((a) * 6.28318531 / 100.0), cos((a) * 6.28318531 / 100.0))

float circles(vec2 p)
        {
        float v, w, l, c;
        vec2 pp;
        l = length(p);
        
        
        pp = rotate(p, time * -3.0);
        c = max(dot(pp, normalize(vec2(-0.75, 0.5))), -dot(pp, normalize(vec2(0.2, 0.5))));
        c = min(c, max(dot(pp, normalize(vec2(0.5, -0.5))), -dot(pp, normalize(vec2(0.2, -0.5)))));
        c = min(c, max(dot(pp, normalize(vec2(0.3, 0.5))), -dot(pp, normalize(vec2(0.2, 0.5)))));
        
        // innerest stuff
        v = abs(l - 0.5) - 0.03;
        v = max(v, -c);
        v = min(v, abs(l - 0.35) - 0.0002);
        v = min(v, abs(l - 0.75) - 0.005);
        
        pp = rotate(p, time * -1.333);
        c = max(dot(pp, A2V(-5.0)), -dot(pp, A2V(5.0)));
        c = min(c, max(dot(pp, A2V(25.0 - 5.0)), -dot(pp, A2V(25.0 + 5.0))));
        c = min(c, max(dot(pp, A2V(50.0 - 5.0)), -dot(pp, A2V(50.0 + 5.0))));
        c = min(c, max(dot(pp, A2V(70.0 - 5.0)), -dot(pp, A2V(75.0 + 5.0))));
        
        w = abs(l - 0.83) - 0.09;
        v = min(v, max(w, c));
        
        return v;
        }

float shade1(float d)
        {
        float v = 1.0 - smoothstep(0.0, mix(0.012, 0.2, 0.0), d);
        float g = exp(d * -20.0);
        return v + g * 0.5;
        }


void main()
        {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        uv = uv * 2.0 - 1.0;
        uv.x *= resolution.x / resolution.y;
        
        
        // using an iq styled camera this time :)
        // ray origin
        vec3 ro = 0.7 * vec3(cos(0.2 * time), 0.0, sin(0.2 * time));
        ro.y = cos(0.6 * time) * 0.3 + 0.65;
        // camera look at
        vec3 ta = vec3(0.0, 0.2, 0.0);
        
        // camera shake intensity
        float shake = 0.0;
        float st = mod(time, 10.0) * 143.0;
        
        // build camera matrix
        vec3 ww = normalize(ta - ro + noise31(st) * shake * 0.01);
        vec3 uu = normalize(cross(ww, normalize(vec3(0.0, 1.0, 0.2 * cos(time)))));
        vec3 vv = normalize(cross(uu, ww));
        // obtain ray direction
        vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.0 * ww);
        
        // shaking and movement
        ro += noise31(-st) * shake * 0.015;
        ro.x += time * 2.0;
        
        float inten = 0.0;
        
        // background
        float sd = dot(rd, vec3(0.0, 1.0, 0.0));
        inten = pow(1.0 - abs(sd), 16.0) + pow(sky(rd), 5.0) * step(0.0, rd.y) * 0.2;
        
        vec3 its;
        float v, g;
        
        // voronoi floor layers
        for(int i = 0; i < 16; i ++)
                {
                float layer = float(i);
                its = intersect(ro, rd, vec3(0.0, -5.0 - layer * 5.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));
                if(its.x > 0.0)
                        {
                        vec3 vo = voronoi((its.yz) * 0.05 + 8.0 * rand21(float(i)));
                        v = exp(-100.0 * (vo.z - 0.02));
                        
                        float fx = 0.0;
                        
                        // add some special fx to lowest layer
                        if(i == 3)
                                {
                                float crd = 0.0;//fract(time * 0.2) * 50.0 - 25.0;
                                float fxi = cos(vo.x * 0.2 + time * 1.5);//abs(crd - vo.x);
                                fx = clamp(smoothstep(0.9, 1.0, fxi), 0.0, 0.9) * 1.0 * rand12(vo.xy);
                                fx *= exp(-3.0 * vo.z) * 2.0;
                                }
                        inten += v * 0.1 + fx;
                        }
                }
        
/*      // draw the gates, 4 should be enough
        float gatex = floor(ro.x / 8.0 + 0.5) * 8.0 + 4.0;
        float go = - 10.0;
        for(int i = 0; i < 2; i ++)
                {
                its = intersect(ro, rd, vec3(gatex + go, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));
                if(dot(its.yz, its.yz) < 2.0 && its.x > 0.0)
                        {
                        v = circles(its.yz);
                        inten += shade1(v);
                        }
                
                go += 8.0;
                }
*/      
        // draw the stream
/*      for(int j = 0; j < 5; j ++)
                {
                float id = float(j);
                
                vec3 bp = vec3(0.0, (rand11(id) * 2.0 - 1.0) * 0.25, 0.0);
                vec3 its = intersect(ro, rd, bp, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));
                
                if(its.x > 0.0)
                        {
                        vec2 pp = its.yz;
                        float spd = (1.0 + rand11(id) * 3.0) * 2.5;
                        pp.y += time * spd;
                        pp += (rand21(id) * 2.0 - 1.0) * vec2(0.3, 1.0);
                        float rep = rand11(id) + 1.5;
                        pp.y = mod(pp.y, rep * 2.0) - rep;
                        float d = box(pp, vec2(0.02, 0.3), 0.1);
                        float foc = 0.0;
                        float v = 1.0 - smoothstep(0.0, 0.03, abs(d) - 0.001);
                        float g = min(exp(d * -20.0), 2.0);
                        
                        inten += (v + g * 0.7) * 0.5;
                        
                        }
                }
*/      
        inten *= 0.5 + (sin(time) * 0.5 + 0.5) * .6;
        
        vec3 col = pow(vec3(inten), vec3(1.0, 1.0, .3));
        
        gl_FragColor = vec4(col, 1.0);
        }
</script>

<!-- http://glsl.heroku.com/e#18916.0 -->
<script id='18916.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform sampler2D bb;

//keep the mouse near center, but as you go far enough left or right, you can do a barrel roll.
//uncomment to reverse vertical control, as in flight and not in arcade
//#define SIM

vec2 rotate(vec2 p, float a)
        {
        return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
        }
float box(vec2 p, vec2 b, float r)
        {
        return length(max(abs(p) - b, 0.0)) - (r * 2.0);
        }

vec3 intersect(in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v)
        {
        vec3 q = o - c;
        return vec3(
        dot(cross(u, v), q),
        dot(cross(q, u), d),
        dot(cross(v, q), d)) / dot(cross(v, u), d);
        }

float rand11(float p)
        {
        return fract(sin(p * 591.32) * 43758.5357);
        }
float rand12(vec2 p)
        {
        return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5357);
        }
vec2 rand21(float p)
        {
        return fract(vec2(sin(p * 591.32), cos(p * 391.32)));
        }

vec2 rand22(in vec2 p)
        {
        return fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));
        }

float noise11(float p)
        {
        float fl = floor(p);
        return mix(rand11(fl), rand11(fl + 1.0), fract(p));//smoothstep(0.0, 1.0, fract(p)));
        }
float fbm11(float p)
        {
        return noise11(p) * 0.5 + noise11(p * 2.0) * 0.25 + noise11(p * 5.0) * 0.125;
        }
vec3 noise31(float p)
        {
        return vec3(noise11(p), noise11(p + 18.952), noise11(p - 11.372)) * 2.0 - 1.0;
        }

float sky(vec3 p)
        {
        float a = atan(p.x, p.z);
        float t = time * 0.1;
        float v = rand11(floor(a * 4.0 + t)) * 0.5 + rand11(floor(a * 8.0 - t)) * 0.25 + rand11(floor(a * 16.0 + t)) * 0.125;
        return v;
        }

vec3 voronoi(in vec2 x)
        {
        vec2 n = floor(x); // grid cell id
        vec2 f = fract(x); // grid internal position
        vec2 mg; // shortest distance...
        vec2 mr; // ..and second shortest distance
        float md = 5.0, md2 = 1.0;
        for(int j = -1; j <= 1; j ++)
                {
                for(int i = -1; i <= 1; i ++)
                        {
                        vec2 g = vec2(float(i), float(j)); // cell id
                        vec2 o = rand22(n + g); // offset to edge point
                        vec2 r = g + o - f;
                        
                        float d = max(abs(r.x), abs(r.y)); // distance to the edge
                        
                        if(d < md)
                                {
                                md2 = md; md = d; mr = r; mg = g;
                                }
                        else if(d < md2)
                                {
                                md2 = d;
                                }
                        }
                }
        return vec3(n + mg, md2 - md);
        }

#define A2V(a) vec2(sin((a) * 6.28318531 / 100.0), cos((a) * 6.28318531 / 100.0))

float circles(vec2 p)
        {
        float v, w, l, c;
        vec2 pp;
        l = length(p);
        
        
        pp = rotate(p, time * -3.0);
        c = max(dot(pp, normalize(vec2(-0.75, 0.5))), -dot(pp, normalize(vec2(0.2, 0.5))));
        c = min(c, max(dot(pp, normalize(vec2(0.5, -0.5))), -dot(pp, normalize(vec2(0.2, -0.5)))));
        c = min(c, max(dot(pp, normalize(vec2(0.3, 0.5))), -dot(pp, normalize(vec2(0.2, 0.5)))));
        
        // innerest stuff
        v = abs(l - 0.5) - 0.03;
        v = max(v, -c);
        v = min(v, abs(l - 0.35) - 0.0002);
        v = min(v, abs(l - 0.75) - 0.005);
        
        pp = rotate(p, time * 10.333);
        c = max(dot(pp, A2V(-5.0)), -dot(pp, A2V(5.0)));
        c = min(c, max(dot(pp, A2V(25.0 - 5.0)), -dot(pp, A2V(25.0 + 5.0))));
        c = min(c, max(dot(pp, A2V(50.0 - 5.0)), -dot(pp, A2V(50.0 + 5.0))));
        c = min(c, max(dot(pp, A2V(70.0 - 5.0)), -dot(pp, A2V(75.0 + 5.0))));
        
        w = abs(l - 0.83) - 0.09;
        v = min(v, max(w, c));
        
        return v;
        }

float shade1(float d)
        {
        float v = 1.0 - smoothstep(0.0, mix(0.012, 0.2, 0.0), d);
        float g = exp(d * -20.0);
        return v + g * 0.5;
        }


void main()
        {
        const float twopi = 6.2831853;
        vec4 old = texture2D(bb,vec2(0.0));
        vec2 oldpos = (time < 2.0) ? vec2(0.5) : old.rg;
        float oldroll = (time < 2.0) ? 0.5 : old.b;
        float tunnel = 14.0; //limits
        vec2 op = (oldpos - 0.5) * tunnel;
        vec2 ms = mouse-0.5;
#ifdef SIM
        ms.y = -ms.y;
#endif
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        uv = uv * 2.0 - 1.0;
        uv.x *= resolution.x / resolution.y;
        
        
        // using an iq styled camera this time :)
        // ray origin
        vec3 ro = 0.7 * vec3(0.0, op.y, op.x);
        // camera look at
        vec3 ta = vec3(1.0, ms.y, ms.x) * 48.;
        
        //also stateful
        float roll = twopi * (oldroll - 0.5) + ms.x * 0.7;

        // build camera matrix
        vec3 ww = normalize(ta - ro);
        vec3 uu = normalize(cross(ww, vec3(0.0, cos(roll), sin(roll))));
        vec3 vv = normalize(cross(uu, ww));
        // obtain ray direction
        vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.0 * ww);
        
        // shaking and movement
        ro.x += time * 2.0;
        
        float blue = 0.0;
        float red = 0.0;
        float green = 0.0;
        
        // background
        float sd = dot(rd, vec3(0.0, 1.0, 0.0));
        blue = pow(1.0 - abs(sd), 16.0) + pow(sky(rd), 5.0) * step(0.0, rd.y) * 0.2;
        
        vec3 its;
        float v, g;
        
        // voronoi floor layers
        for(int i = 0; i < 16; i ++)
                {
                float layer = float(i);
                its = intersect(ro, rd, vec3(0.0, -5.0 - layer * 5.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));
                if(its.x > 0.0)
                        {
                        vec3 vo = voronoi((its.yz) * 0.05 + 8.0 * rand21(float(i)));
                        v = exp(-100.0 * (vo.z - 0.02));
                        
                        float fx = 0.0;
                        
                        // add some special fx to lowest layer
                        if(i == 3)
                                {
                                float crd = 0.0;//fract(time * 0.2) * 50.0 - 25.0;
                                float fxi = cos(vo.x * 0.2 + time * 1.5);//abs(crd - vo.x);
                                fx = clamp(smoothstep(0.9, 1.0, fxi), 0.0, 0.9) * 1.0 * rand12(vo.xy);
                                fx *= exp(-3.0 * vo.z) * 2.0;
                                }
                        blue += v * 0.1 + fx;
                        }
                }
        
        // draw the gates
        float gatex = floor(ro.x / 8.0 + 0.5) * 8.0 - 4.0;
        const int ngates = 16;
        float gateSize = 10.;
        float go = 8.0;
        for(int i = 0; i < ngates; i ++)
                {
                float rx = cos(time*0.9878915919)*2. + cos(-time*1.1591)*3.;
                float ry = sin(time*0.87416981)*2. + sin(-time*0.998402)*3.;
                its = intersect(ro, rd, vec3(gatex + go, rx, ry), vec3(0.0, gateSize, 0.0), vec3(0.0, 0.0, gateSize));
                //if(dot(its.yz, its.yz) < 2.0 && its.x > 0.0)
                        {
                        v = circles(its.yz);
                        red += shade1(v);
                        }
                
                go += 8.0;
                }
        
        // draw the stream
        for(int j = 0; j < 5; j ++)
                {
                float id = float(j);
                
                vec3 bp = vec3(0.0, (rand11(id) * 2.0 - 1.0) * 0.25, 0.0);
                vec3 its = intersect(ro, rd, bp, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));
                
                if(its.x > 0.0)
                        {
                        vec2 pp = its.yz;
                        float spd = (1.0 + rand11(id) * 3.0) * 2.5;
                        pp.y += time * spd;
                        pp += (rand21(id) * 2.0 - 1.0) * vec2(0.3, 1.0);
                        float rep = rand11(id) + 1.5;
                        pp.y = mod(pp.y, rep * 2.0) - rep;
                        float d = box(pp, vec2(0.02, 0.3), 0.1);
                        float foc = 0.0;
                        float v = 1.0 - smoothstep(0.0, 0.03, abs(d) - 0.001);
                        float g = min(exp(d * -20.0), 2.0);
                        
                        green += (v + g * 0.7) * 0.5;
                        
                        }
                }
        vec3 rgb = vec3(0.0);
#if 1
        float inten = 1.0; //0.4 + (sin(time*0.3) * 0.5 + 0.5) * 0.6;
        float desat = 0.2 * (cos(time*3.) * 0.5 + 0.5) + 0.07;
        rgb.b = inten * (blue + desat * (red+green));
        rgb.r = inten * (red + desat * (blue+green));
        rgb.g = inten * (green + desat * (red+blue));
#else
        rgb = vec3(red,green,blue);
#endif
        vec3 col = pow(rgb, vec3(1.0, 1.0, 1.25));
        float mn = 0.1; //maneuverability
        if (int(gl_FragCoord.x) == 0) {
        if (int(gl_FragCoord.y) == 0)
        {
                col.r = oldpos.x + (ms.x * mn);
                col.g = oldpos.y + (ms.y * mn);
                col.b = mix(0.5, fract(oldroll + (0.0008 * (pow(7., 5.0 * abs(ms.x))) * sign(ms.x))), abs(ms.x * 2.0)); //fixme: this is sloppy
        }
        }
        gl_FragColor = vec4(col, 1.0);

        }
</script>

<!-- http://glsl.heroku.com/e#18713.0 -->
<script id='18713.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

//#define EASY_MODE
#ifdef EASY_MODE
const float pipeSpacing = 300
        .0;
const float pipeHole = 150.0;
#else
const float pipeSpacing = 600.0;
const float pipeHole = 100.0;
#endif

uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform sampler2D backbuffer;

struct cState
{
    float validData;
    float alive;
    float deadTime;
    float birdPosY;  
     float birdVelY;
       float mouseRegion;
    float score;
    float hiscore;
    float xParity;  // before or after the current pipe? 
};

void resetState( inout cState state )
{
    state.alive = 1.0;
    state.deadTime = 0.0;
    state.birdPosY = 100.0;
    state.birdVelY = 0.0;
    state.mouseRegion = step( 0.5, mouse.y );
    state.score = 0.0;
    state.xParity = 1.0;
}

cState loadState()
{
    // If speed is an issue, we could spoil a few pixels and use RGBA of 3 pixels instead of alpha of 9.
    // A few could be merged as well.
    cState state;
    state.validData =  texture2D(backbuffer,( vec2(0.4,0.0) / resolution.xy )).a;
    state.alive =      texture2D(backbuffer,( vec2(1.4,0.0) / resolution.xy )).a;
    state.deadTime =   texture2D(backbuffer,( vec2(2.4,0.0) / resolution.xy )).a;
    state.birdPosY =   texture2D(backbuffer,( vec2(3.4,0.0) / resolution.xy )).a * 800.0 - 250.0;
    state.birdVelY =   texture2D(backbuffer,( vec2(4.4,0.0) / resolution.xy )).a * 80.0 - 40.0;
    state.mouseRegion = texture2D(backbuffer,( vec2(5.4,0.0) / resolution.xy )).a;
    state.score =       texture2D(backbuffer,( vec2(6.4,0.0) / resolution.xy )).a * 255.0;
    state.hiscore =     texture2D(backbuffer,( vec2(7.4,0.0) / resolution.xy )).a * 255.0;
    state.xParity  =      texture2D(backbuffer,( vec2(8.4,0.0) / resolution.xy )).a;
    
    if( state.validData < 0.25 || state.validData > 0.75 )
    {
        resetState( state );
        state.hiscore = 0.0;
    }
    return state;
}

void saveState( cState state, vec3 col )
{
    // Who loves if statements?
    float alpha = 1.0;
    if( gl_FragCoord.y <= 0.5 )
    {
        if( gl_FragCoord.x <= 0.5 )
            alpha = 0.5;    //valid data
        else if( gl_FragCoord.x <= 1.5 )
            alpha = ( state.alive );
        else if( gl_FragCoord.x <= 2.5 )
            alpha = ( state.deadTime );
        else if( gl_FragCoord.x <= 3.5 )
            alpha = ( state.birdPosY + 250.0 ) / 800.0;
        else if( gl_FragCoord.x <= 4.5 )
            alpha = ( state.birdVelY + 40.0 ) / 80.0;
        else if( gl_FragCoord.x <= 5.5 )
            alpha = state.mouseRegion;
        else if( gl_FragCoord.x <= 6.5 )
            alpha = state.score / 255.0;
        else if( gl_FragCoord.x <= 7.5 )
            alpha = state.hiscore / 255.0;
        else if( gl_FragCoord.x <= 8.5 )
            alpha = state.xParity;
    }
    
    gl_FragColor = vec4( col, alpha );
}

float box( vec2 p, vec4 rect)
{
    float trim = min(rect.z, rect.w) * 0.5;
    float minX = min(p.x - rect.x, rect.x + rect.z - p.x);
    float minY = min(p.y - rect.y, rect.y + rect.w - p.y);
    return step(0.0, minX) * step(0.0, minY) * step(trim, minX + minY);
}

float digit( vec2 p, vec4 dim, float d)
{
        d = (d - mod(d,1.0)) / 10.0;
        d = mod( d, 1.0 );

        p.xy -= dim.xy;
        p.xy /= dim.zw;
        

        float c = 0.0;
        
        // I'm sure all of these can be improved... in fact, this way may actually be slower than just if else if else if else for
        // all ten numbers.  Oh well, it was worth a shot :)
        
        // ed: removed all conditional expressions, should work everywhere

        // top - 0, 2, 3, 5, 7, 8, 9
        c += box(p, vec4(0.05, 0.8, 0.9, 0.2)) * step(cos((0.85*d+0.1)*30.0) - sin(pow(d,1.0)), 0.0);

        // middle - 2, 3, 4, 5, 6, 8, 9
        c += box(p, vec4(0.05, 0.4, 0.9, 0.2)) * step(1.0, min(pow(6.0*d,2.0), pow(20.0*(d-0.7),2.0)));

        // bottom - 0, 2, 3, 5, 6, 8
        c += box(p, vec4(0.05, 0.0, 0.9, 0.2)) * step(0.0, max(cos(18.6*pow(d,0.75)), 1.0-pow(40.0*(d-0.8),2.0)));

        // bottom left - 0, 2, 6, 8
        c += box(p, vec4(0.0, 0.04, 0.2, 0.47)) * step(0.1, cos(d*30.0) * abs(d-0.4));
        
        // bottom right - 0, 1, 3, 4, 5, 6, 7, 8, 9
        c += box(p, vec4(0.8, 0.04, 0.2, 0.47)) * step(0.1, pow(4.0*d-0.8, 2.0));

        // top left - 0, 4, 5, 6, 8, 9
        c += box(p, vec4(0.0, 0.48, 0.2, 0.47)) * step(sin((d-0.05)*10.5) - 12.0*sin(pow(d,10.0)), 0.0);
        
        // top right - 0, 1, 2, 3, 4, 7, 8, 9
        c += box(p, vec4(0.8, 0.48, 0.2, 0.47)) * step(0.02, pow(d-0.55, 2.0));

        return c;
}

float rand(float n)
{
    return fract(sin(n * 12.9898) * 43758.5453)-0.5;
}

float hAt(float i)
{
        return 250.0*rand(i*1.232157);
}

void pipe(inout vec3 col, vec2 p, float h)
{
        vec2 ap = abs(p);
        if (ap.y > h)
        {
                float dy = ap.y - h;
                if (dy < 60.0) ap.x *= 0.93;
                col = mix(col, vec3(0.322, 0.224, 0.290), step(ap.x, 65.0)); // outline
                if (dy > 60.0 || mod(dy, 55.0) > 5.0) 
                {
                        float gradient = 0.0;
                        if (abs(dy - 57.5) > 7.5) gradient = max(0.0, 0.5*cos(floor((p.x+25.0)/5.0)*5.0*(0.026 - 0.006*step(dy, 10.0))));
                        col = mix(col, vec3(0.322, 0.506, 0.129) + gradient, step(ap.x, 60.0)); // pipe
                }
        }
}

// constant-array-index workaround ---
float slice(int id) 
{
        // flappy bird character (no worries, I have a tool)
        if (id == 0) return 2359296.0;
        if (id == 1) return 585.0;
        if (id == 2) return 4489216.0;
        if (id == 3) return 46674.0;
        if (id == 4) return 4751360.0;
        if (id == 5) return 2995812.0;
        if (id == 6) return 8945664.0;
        if (id == 7) return 3003172.0;
        if (id == 8) return 9469963.0;
        if (id == 9) return 7248164.0;
        if (id == 10) return 2359385.0;
        if (id == 11) return 10897481.0;
        if (id == 12) return 6554331.0;
        if (id == 13) return 9574107.0;
        if (id == 14) return 2134601.0;
        if (id == 15) return 9492189.0;
        if (id == 16) return 3894705.0;
        if (id == 17) return 9474632.0;
        if (id == 18) return 2396785.0;
        if (id == 19) return 9585152.0;
        if (id == 20) return 14380132.0;
        if (id == 21) return 8683521.0;
        if (id == 22) return 2398500.0;
        if (id == 23) return 1.0;
        if (id == 24) return 4681.0;    
        return 0.0;     
}

vec3 color(int id)
{
        // flappy bird colors
        if (id == 0) return vec3(0.0);
        if (id == 1) return vec3(0.320,0.223,0.289);
        if (id == 2) return vec3(0.996,0.449,0.063);
        if (id == 3) return vec3(0.965,0.996,0.965);
        if (id == 4) return vec3(0.996,0.223,0.000);
        if (id == 5) return vec3(0.836,0.902,0.805);
        return vec3(0.965,0.707,0.191);
}
// ---

int sprite(vec2 p)
{
        // this time it's 3 bit/px (8 colors) and 8px/slice, 204px total
        int d = 0;
        p = floor(p);
        p.x = 16.0 - p.x;
        
        if (clamp(p.x, 0.0, 16.0) == p.x && clamp(p.y, 0.0, 11.0) == p.y)
        {
                float k = p.x + 17.0*p.y;
                float s = floor(k / 8.0);
                float n = slice(int(s));
                k = (k - s*8.0)*3.0;
                if (int(mod(n/(pow(2.0,k)),2.0)) == 1)          d += 1;
                if (int(mod(n/(pow(2.0,k+1.0)),2.0)) == 1)      d += 2;
                if (int(mod(n/(pow(2.0,k+2.0)),2.0)) == 1)      d += 4;
        }
        return d;
}

void hero(inout vec3 col, vec2 p, float angle)
{
    p -= vec2( 40.0, 27.5 );
        p = vec2(p.x * cos(angle) - p.y * sin(angle), p.y * cos(angle) + p.x * sin(angle));
    p += vec2( 40.0, 27.5 );
    
        int i = sprite(p*0.2);
        col = mix(col, color(i), min(1.0, float(i)));
}

void ground(inout vec3 col, vec2 p)
{
        p = floor(p);
        if (p.y > -280.0) return;
        if (p.y < -285.0) col = color(1);
        if (p.y < -290.0) col = vec3(0.902, 1.000, 0.549);
        if (p.y < -295.0) col = mix(vec3(0.612, 0.906, 0.353), vec3(0.451, 0.745, 0.192), step(mod(p.x-floor(p.y/5.0)*5.0, 60.0), 30.0));
        if (p.y < -325.0) col = vec3(0.322, 0.506, 0.129);
        if (p.y < -330.0) col = vec3(0.839, 0.667, 0.290);
        if (p.y < -335.0) col = vec3(0.871, 0.843, 0.580);
}

void sky(inout vec3 col, vec2 p)
{
        col = mix(col, vec3(1.0), 0.3*sin(p.y*0.01));
}

void main(void)
{
    cState state = loadState();
    
        float s = 2000.0/resolution.x;
        vec2 p = max(1.6666667, s)*(gl_FragCoord.xy - resolution.xy * 0.5);
    
        float dx = time * 320.0;
        p.x += dx;
        
        vec3 col = vec3(0.322, 0.745, 0.808);
        sky(col, vec2(0.0, -100.0)-p);
        
        pipe(col, vec2(mod(p.x, pipeSpacing)-pipeSpacing*0.5, p.y + hAt(floor(p.x / pipeSpacing)) - 80.0), pipeHole);

    if( state.alive < 0.5 )
    {
        state.deadTime += 0.008;
        if( state.deadTime >= 1.0 )
        {
            resetState( state );
        }
    }
    
    if( state.alive > 0.5 )
    {
        float currentMouseRegion = step( 0.5, mouse.y );
        if( currentMouseRegion != state.mouseRegion )
        {
            state.birdVelY = 120.0;
            state.mouseRegion = currentMouseRegion;
        }
    }
        
    state.birdVelY -= 2.0;
    state.birdPosY += state.birdVelY * 0.2;
        
    vec2 birdPos = vec2( dx - 200.0 - 950.0 * state.deadTime, state.birdPosY );
    
    if( birdPos.y < -225.0 )
    {
        state.alive = 0.0;
    }
    
    float birdInPipeSpaceX = mod( birdPos.x, pipeSpacing ) - pipeSpacing * 0.5;
    float pipeY = -hAt( floor( birdPos.x / pipeSpacing ) ) + 80.0;
    
    float xParity = step( 0.0, birdInPipeSpaceX );
    if( state.xParity == 0.0 && xParity == 1.0 && state.alive > 0.5 )
    {
        state.score += 1.0;
    }
    state.xParity = xParity;
    
    if( ( birdInPipeSpaceX > - 60.0 ) && ( birdInPipeSpaceX < 120.0 ) )
    {
        if( ( birdPos.y < pipeY - pipeHole + 55.0 ) )
        {
            state.alive = 0.0;
        }        
        else if( ( birdPos.y > pipeY + pipeHole + 20.0 ) )
        {
            state.alive = 0.0;
        }        
    }
    
    float angle = clamp( -state.birdVelY * 0.05, -0.3, 1.0 );
    if( state.alive < 0.5 )
    {
        angle = 3.14;
    }
        hero(col, birdPos-p, angle);
        
        ground(col, p);
    
    vec2 dp = ( gl_FragCoord.xy / resolution.xy );
    if( state.score >= 100.0 )
        col += digit( dp, vec4( 0.1, 0.90, 0.05, 0.05 ), state.score/100.0 );
    if( state.score >= 10.0          )
        col += digit( dp, vec4( 0.16, 0.90, 0.05, 0.05 ), state.score/10.0 );
    col += digit( dp, vec4( 0.22, 0.90, 0.05, 0.05 ), state.score );
    
    state.hiscore = max( state.hiscore, state.score );
    if( state.hiscore >= 100.0 )
        col += digit( dp, vec4( 0.72, 0.90, 0.05, 0.05 ), state.hiscore/100.0 );
    if( state.hiscore >= 10.0 )
        col += digit( dp, vec4( 0.78, 0.90, 0.05, 0.05 ), state.hiscore/10.0 );
    col += digit( dp, vec4( 0.84, 0.90, 0.05, 0.05 ), state.hiscore );

    saveState( state, col );
}

</script>

<!-- http://glsl.heroku.com/e#18613.0 -->
<script id='18613.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2  resolution;
uniform float time;
uniform vec2 mouse;

float PI = 3.1415926535;

void main( void ) {
    float time = time * 0.01+length(mouse)*3e2;
    vec2 p=(gl_FragCoord.xy -.5 * resolution)/ min(resolution.x,resolution.y)/2.;
    vec3 c = vec3(0);
    vec3 c2 = vec3(0);
        
    for(int i = 0; i < 128; i++){
        float t = (1.5 + .3 ) * PI * float(i+3) / 10. * time*0.05;
        float x = .05 * cos(t);
        float y = .05* sin(t);
        vec2 o = 1.45 * vec2(0.5*x,.5*y);
        float hue = time*0.03*float(i+5)*1e3;
        float r = max(sin(hue)+0.35, 0.2);
        float g = max(sin(hue+PI*3./4.)+0.15, 0.2);
        float b = max(sin(hue+PI*5./4.)+0.15, 0.2);
        c += 1e-3/(length(2.0*p-o*5.*(1.2-cos(time*((0.205)*float(i+17))))))*vec3(r,g,b);
        //c += 0.003/(length(2.0*p-o*5.*(1.2-cos(time*float(i+7)))))*vec3(r,g,b);
          
    }

    gl_FragColor = vec4(c,99);
        
}
</script>

<!-- http://glsl.heroku.com/e#18568.0 -->
<script id='18568.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2  resolution;
uniform float time;
uniform vec2 mouse;

float PI = 3.1415926535;

void main( void ) {
    vec2 p=(gl_FragCoord.xy -.5 * resolution)/ min(resolution.x,resolution.y)/2.;
    vec3 c = vec3(0);
    vec3 c2 = vec3(0);
        
    for(int i = 0; i < 50; i++){
    float t = (1.5 + .3 * mouse.x) * PI * float(i+3) / 10. * time*0.05;
    float x = .05 * cos(t);
    float y = .05* sin(t);
    vec2 o = 1.45 * vec2(0.5*x,.5*y);
    float hue = time*0.03*float(i+5);
    float r = max(sin(hue)+0.35, 0.2);
    float g = max(sin(hue+PI*3./4.)+0.15, 0.2);
    float b = max(sin(hue+PI*5./4.)+0.15, 0.2);
     c += 0.003/(length(2.0*p-o*5.*(1.2-cos(time*((0.205+0.00005*mouse.y)*float(i+17))))))*vec3(r,g,b);
//      c += 0.003/(length(2.0*p-o*5.*(1.2-cos(time*float(i+7)))))*vec3(r,g,b);
            
    }

    gl_FragColor = vec4(c,99);
        
}
</script>

<!-- http://glsl.heroku.com/e#18451.0 -->
<script id='18451.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

// rakesh@picovico.com : www.picovico.com

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

const float fRadius = 0.2;

void main(void)
{
    vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
    uv.x *=  resolution.x / resolution.y;
    
    vec3 color = vec3(0.0);

        // bubbles
    for( int i=0; i<64; i++ )
    {
            // bubble seeds
        float pha = tan(float(i)*6.+1.0)*0.5 + 0.5;
        float siz = pow( cos(float(i)*2.4+5.0)*0.5 + 0.5, 4.0 );
        float pox = cos(float(i)*3.55+4.1) * resolution.x / resolution.y;
        
            // buble size, position and color
        float rad = fRadius + sin(float(i))*0.12+0.08;
        vec2  pos = vec2( pox+sin(time/30.+pha+siz), -1.0-rad + (2.0+2.0*rad)
                         *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0)) * vec2(1.0, 1.0);
        float dis = length( uv - pos );
        vec3  col = mix( vec3(0.1, 0.2, 0.8), vec3(0.2,0.8,0.6), 0.5+0.5*sin(float(i)*sin(time*pox*0.03)+1.9));
        
            // render
        color += col.xyz *(1.- smoothstep( rad*(0.65+0.20*sin(pox*time)), rad, dis )) * (1.0 - cos(pox*time));
    }

    gl_FragColor = vec4(color,1.0);
}
</script>

<!-- http://glsl.heroku.com/e#19297.0 -->
<script id='19297.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main(void)
{
        vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
        uv.x *=  resolution.x / resolution.y;
        
    // background        
        vec3 color = vec3(0.8 + 0.2*uv.y);

    // bubbles  
        for( int i=0; i<80; i++ )
        {
        // bubble seeds
                float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;
                float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );
                float pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;
                
        // buble size, position and color
                float rad = 0.1 + 0.5*siz;
                vec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*time*(0.2+0.8*siz),1.0));
                float dis = length( uv - pos );
                vec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));
                //    col+= 8.0*smoothstep( rad*0.95, rad, dis );
                
        // render
                float f = length(uv-pos)/rad;
                f = sqrt(clamp(1.0-f*f,0.0,1.0));
                color -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;
        }

    // vigneting        
        color *= sqrt(1.5-0.5*length(uv));

        gl_FragColor = vec4(color,1.0);
}
</script>

<!-- http://glsl.heroku.com/e#18759.0 -->
<script id='18759.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float gTime = time+11.0;

void main( void )
{
        float f = 3., g = 3.;
        vec2 res = resolution.xy;
        vec2 mou = mouse.xy;
        
        //if (mouse.x < 0.5)
        //{
        mou.x = sin(gTime * .3)*sin(gTime * .17) * 1. + sin(gTime * .3);
        mou.y = (1.0-cos(gTime * .632))*sin(gTime * .131)*1.0+cos(gTime * .3);
        mou = (mou+1.0) * res;
        //}
        vec2 z = ((-res+2.0 * gl_FragCoord.xy) / res.y);
        vec2 p = ((-res+2.0+mou) / res.y);
        for( int i = 0; i < 10; i++) 
        {
                float d = dot(z,z);
                z = (vec2( z.x, -z.y ) / d) + p; 
                z.x =  abs(z.x);
                f = max( f, (dot(z-p,z-p) ));
                g = min( g, sin(dot(z+p,z+p))+1.0);
        }
        f = abs(-log(f) / 3.5);
        g = abs(-log(g) / 8.0);
        gl_FragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);
}
</script>

<!-- http://glsl.heroku.com/e#19336.0 -->
<script id='19336.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

#define RRatio 0.1796875
#define GRatio 0.55859375
#define BRatio 0.62890625



#define cirR 0.1953125
#define cirG 0.5859375
#define cirB 0.6640625

#define partCol 0.73046875

#define CIRCLE 2
#define CircleLine 0.01

#define partSize 0.005



void main( void ) {

vec2 position = (gl_FragCoord.xy / resolution.xy);
vec2 center = (resolution *0.5);
float backgroundIntensity = 1.-length(position - center/resolution.xy)*1.5;
gl_FragColor = vec4(0.0);
float circDelay = 0.0;
vec4 lineColor = vec4(cirR,cirG,cirB,1.0);
vec4 partColor = vec4(partCol,partCol,partCol,1.0);
for (int i = 0 ; i < CIRCLE; i++)
{
float distCir = sin(length(center.xy - gl_FragCoord.xy) / resolution.x + circDelay -time*0.5);
if (distCir > 0.01 && distCir < 0.011111) {
gl_FragColor += lineColor;
} 
circDelay+= 0.1;
}
vec2 realMouse = vec2(mouse.x* resolution.x, mouse.y* resolution.y);
float size = length(gl_FragCoord.xy - realMouse.xy)/resolution.x;
if (  size < partSize ) {
gl_FragColor += vec4(1.0 - pow(size/partSize,1.5));
}
float partDist = sin(length(center.xy - gl_FragCoord.xy) / resolution.x + time*0.5);
//angle?
vec2 positionFromCenter =  ( gl_FragCoord.xy -  resolution.xy*.5 ) / resolution.x;
float angle = atan(positionFromCenter.y,positionFromCenter.x)/(2.*3.14159265359);
angle -= floor(angle);
float rad = length(positionFromCenter);
vec4 color = vec4(0.0);
for (int i = 0; i < 1; i++) {
float angleFract = fract(angle*256.);
float angleRnd = floor(angle*256.)+1.;
float angleRnd1 = fract(angleRnd*fract(angleRnd*.7235)*45.1);
float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*13.724);
float t = -time*0.1+angleRnd1*10.;
float radDist = sqrt(angleRnd2+float(i));

float adist = radDist/rad*.03;
float dist = (t*.3+adist);
dist = abs(fract(dist)-.5);
//       float c = sin(float(i) / 4.0) + 1.0;
if (.5-dist*40./adist > 0.0) {
color += ((.5-dist*40./adist)*(.5-abs(angleFract-.5))*5./adist/radDist) * partColor;//vec4(c*angleRnd1,c*angleRnd2,c*(angleRnd1+angleRnd2),1.0);
}
//color += (max(0.,.5-dist*40./adist)*(.5-abs(angleFract-.5))*5./adist/radDist) * partColor;//vec4(c*angleRnd1,c*angleRnd2,c*(angleRnd1+angleRnd2),1.0);
angle = fract(angle+.61);
}
//Apply background color
gl_FragColor = gl_FragColor + vec4( vec3(RRatio, GRatio, BRatio) * backgroundIntensity, 1.0 )+color;
}
</script>

<!-- http://glsl.heroku.com/e#18981.0 -->
<script id='18981.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main(void)
{
        vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
        uv.x *=  resolution.x / resolution.y;
        
    // background        
        vec3 color = vec3(0.8 + 0.4*uv.y);

    // bubbles  
        for( int i=0; i<40; i++ )
        {
        // bubble seeds
                float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;
                float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );
                float pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;
                
        // buble size, position and color
                float rad = 0.1 + 0.5*siz;
                vec2  pos = vec2( pox + siz*sin(time+float(i)), -1.0-rad + (2.0+2.0*rad)*mod(pha+0.4*time*(0.2+0.8*siz),1.0));
                float dis = length( uv - pos );
                vec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));
                //    col+= 8.0*smoothstep( rad*0.95, rad, dis );
                
        // render
                float f = length(uv-pos)/rad;
                f = sqrt(clamp(1.0-f*f,0.0,1.0));
                color -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;
        }

    // vigneting        
        color *= sqrt(1.8-0.7*length(uv));

        gl_FragColor = vec4(color,1.0);
}
</script>

<!-- http://glsl.heroku.com/e#18543.2 -->
<script id='18543.2_' type='x-shader/x-fragment'>
/*
  Daily an hour GLSL sketch by @chimanaco 3/30

  References:
  http://tokyodemofest.jp/2014/7lines/index.html
*/

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2  resolution;
uniform float time;
uniform vec2 mouse;

float PI = 3.1415926535;

void main( void ) {
    vec2 p=(gl_FragCoord.xy -.5 * resolution)/ min(resolution.x,resolution.y);
    vec3 c = vec3(0);
   
    for(int i = 0; i < 128; i++){
    float t = 3.* PI * float(i) / 200. * fract(time*0.95);
    float x = cos(t/cos(time+time*time)) / sin(t-time*time+p.y*1e1);
    float y = sin(-t+p.x*16.);
    vec2 o = 0.145 * vec2(x,y)/cos(time*1e-1);
    float r = fract(t);
    float g = 1.-r;
    float b = 1.-r;
    c += 8e-4/(length(p-o))*vec3(r,g,b);
    }
    gl_FragColor = vec4(c,1);
}
</script>

<!-- http://glsl.heroku.com/e#18543.2 -->
<script id='18543.2' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main( void ) {

        vec2 position = ( gl_FragCoord.xy / resolution.xy ) + mouse / 4.0;

        float color = 0.0;
        color += sin( position.x * cos( time / 10.0 ) * 90.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
        color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );
        color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );
        color *= sin( time / 10.0 ) * 0.5;

        gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );

}
</script>

<!-- http://glslsandbox.com/e#19674.0 -->
<script id='19674.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// rotate position around axis
vec2 rotate(vec2 p, float a)
{
        return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
}

// 1D random numbers
float rand(float n)
{
    return fract(sin(n) * 43758.5453123);
}

// 2D random numbers
vec2 rand2(in vec2 p)
{
        return fract(vec2(sin(p.x * 591.32 + p.y * 154.077 + time), cos(p.x * 391.32 + p.y * 49.077 + time)));
}

// 1D noise
float noise1(float p)
{
        float fl = floor(p);
        float fc = fract(p);
        return mix(rand(fl), rand(fl + 1.0), fc);
}

// voronoi distance noise, based on iq's articles
float voronoi(in vec2 x)
{
        vec2 p = floor(x);
        vec2 f = fract(x);
        
        vec2 res = vec2(8.0);
        for(int j = -1; j <= 1; j ++)
        {
                for(int i = -1; i <= 1; i ++)
                {
                        vec2 b = vec2(i, j);
                        vec2 r = vec2(b) - f + rand2(p + b);
                        
                        // chebyshev distance, one of many ways to do this
                        float d = max(abs(r.x), abs(r.y));
                        
                        if(d < res.x)
                        {
                                res.y = res.x;
                                res.x = d;
                        }
                        else if(d < res.y)
                        {
                                res.y = d;
                        }
                }
        }
        return res.y - res.x;
}


float flicker = noise1(time * 2.0) * 0.8 + 0.4;

void main(void)
{
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        uv = (uv - 0.5) * 2.0;
        vec2 suv = uv;
        uv.x *= resolution.x / resolution.y;
        
        
        float v = 0.0;
        
        // that looks highly interesting:
        //v = 1.0 - length(uv) * 1.3;
        
        
        // a bit of camera movement
        //uv *= 0.6 + sin(time * 0.1) * 0.4;
        uv = rotate(uv, sin(0.0 * 0.3) * 1.0);
        //uv += time * 0.4;
        
        
        // add some noise octaves
        float a = 0.6, f = 1.0;
        
        for(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though
        {       
                float v1 = voronoi(uv * f + 5.0);
                float v2 = 0.0;
                
                // make the moving electrons-effect for higher octaves
                if(i > 0)
                {
                        // of course everything based on voronoi
                        v2 = voronoi(uv * f * 0.5 + 50.0 + time);
                        
                        float va = 0.0, vb = 0.0;
                        va = 1.0 - smoothstep(0.0, 0.1, v1);
                        vb = 1.0 - smoothstep(0.0, 0.08, v2);
                        v += a * pow(va * (0.5 + vb), 2.0);
                }
                
                // make sharp edges
                v1 = 1.0 - smoothstep(0.0, 0.3, v1);
                
                // noise is used as intensity map
                v2 = a * (noise1(v1 * 5.5 + 0.1));
                
                // octave 0's intensity changes a bit
                if(i == 0)
                        v += v2 * flicker;
                else
                        v += v2;
                
                f *= 3.0;
                a *= 0.7;
        }

        // slight vignetting
        v *= exp(-0.6 * length(suv)) * 1.2;
        
        // use texture channel0 for color? why not.
        //vec3 cexp = texture2D(iChannel0, uv * 0.001).xyz * 3.0 + texture2D(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);
        
        // old blueish color set
        vec3 cexp = vec3(2.0, 1.1, 0.0);
                cexp *= 1.3;

        vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;
        
        gl_FragColor = vec4(col, 2.0);
}
</script>

<!-- http://glslsandbox.com/e#19624.0 -->
<script id='19624.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main( void ) {

        vec2 p = ( gl_FragCoord.xy / resolution.xy );
        float pi = 3.141592653589793;
        float theta = pi / 4.0;
        #define time time + atan(p.x, p.y)*2.0
        mat2 m = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));
        p = p * 2.0 - 1.0;
        p.x *= resolution.x / resolution.y;
        p = m * p;
        vec2 f = fract(p * 5.0);
        f = 2.0 * f - 1.0;
        
        float df = distance(f, vec2(0.0, 0.0));
        df = 3.0*df*df - 2.0*df*df*df;
        float dp = max(1.5 - distance(p, vec2(0.0, 0.0)), 0.0);
        dp = 3.0*dp*dp - 2.0*dp*df*df;
        float from = 0.3 + sin(dp * pi * 0.5 + time * 0.5) * 0.75;
        float to = from + 0.05;
        float d = smoothstep(from, to, df);
        
        float col = 0.0;
        col = d; 

        gl_FragColor = vec4( vec3( col ), 1.0 );

}
</script>

<!-- http://glsl.heroku.com/e#18357.1 -->
<script id='18357.1' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;

uniform vec2 resolution;

#define PI 90

void main( void ) {

        vec2 p = ( gl_FragCoord.xy / resolution.xy ) - 0.2;
        
        float time = time + pow(cos(p.x*133.)*cos(p.x*133.), sin(p.y*55.)*sin(p.y*64.));
        
        p.y += sin(p.x+time)*0.5/p.x;
        
        float sx = 0.3 * (p.x + 0.8) * sin( 25.0 * p.x - 1. * pow(time, 0.9)*10.);
        
        float dy;
        //dy = 4./ ( 123. * abs(p.y - sx));
        dy = 1./ (10. * length(p - vec2(p.x, 0.5)));
        dy += 1./ (10. * length(p - vec2(p.x, 0.)));
        
        
        gl_FragColor = vec4( (p.x + 0.1) * dy, 0.3 * dy, dy, 2.1 );

}
</script>

<!-- http://glsl.heroku.com/e#18794.0 -->
<script id='18794.0' type='x-shader/x-fragment'>
// "Cobweb" by Kabuto 
// Based on @ahnqqq's blob raymarcher

# ifdef GL_ES
precision mediump float;
# endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform sampler2D backbuffer;

vec3 diffuse = vec3( .99, .75, 1. );
const vec3 eps = vec3( .001, 0., 0. );
const int iter = 128;
float sq = sqrt(2.0)*0.5;

float c( vec3 p )
{
        vec3 q = abs(mod(p+vec3(cos(p.z*0.5), cos(p.x*0.5), cos(p.y*0.5)),2.0)-1.0);
        float a = q.x + q.y + q.z - min(min(q.x, q.y), q.z) - max(max(q.x, q.y), q.z);
        q = vec3(p.x+p.y, p.y+p.z, p.z+p.x)*sq;
        q = abs(mod(q,2.0)-1.0);
        float b = q.x + q.y + q.z - min(min(q.x, q.y), q.z) - max(max(q.x, q.y), q.z);
        return min(a,b);
}

vec3 n( vec3 p )
{
        float o = c( p );
        return normalize( o - vec3( c( p - eps ), c( p - eps.zxy ), c( p - eps.yzx ) ) );
}

void main()
{
        float r = resolution.x / resolution.y;
        vec2 p = gl_FragCoord.xy / resolution * 2. - 1.;
        vec2 m = mouse + vec2(0.5,-0.5);
        p.x *= r;
        m.x *= r;
        diffuse.r = -cos(time/1.0)*2.0;
        diffuse.b = -tan(time/1.0)*2.0;
        
        vec3 o = vec3( 0., 0., time*2. );
        vec3 s = vec3( m, 0. );
        vec3 b = vec3( 0., 0., 0. );
        vec3 d = vec3( p, 1. ) / 32.;
        vec3 t = vec3( .5 );
        vec3 a;
        
        for( int i = 0; i < iter; ++i )
        {
                float h = c( b + s + o );
                //if( h < 0. )
                //      break;
                b += h * 10.0 * d;
                t += h;
        }
        t /= float( iter );
        a = n( b + s + o );
        float x = dot( a, t );
        t = ( t + pow( x, 4. ) ) * ( 1. - t * .01 ) * diffuse;

        gl_FragColor = vec4( t, 1. );
}
</script>

<!-- http://glsl.heroku.com/e#1674.0 -->
<script id='1674.0' type='x-shader/x-fragment'>
/* lame-ass tunnel by kusma */

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;




float rand (float x) {
        return fract(sin(x * 24614.63) * 36817.352);    
}

void main( void ) {
        vec2 position = (gl_FragCoord.xy - resolution * 0.5) / resolution.yy;
        float th = atan(position.y, position.x) / (2.0 * 3.1415926) + 10.0;
        float dd = length(position);
        float d = 0.5 / dd + time;

        vec3 uv = vec3(th + d, th - d, th + sin(d));
        float a = 0.5 + cos(uv.x * 3.1415926 * 2.0) * 0.3;
        float b = 0.5 + cos(uv.y * 3.1415926 * 8.0) * 0.3;
        float c = 0.5 + cos(uv.z * 3.1415926 * 6.0) * 0.5;
        float f = abs(sin(time*2.0));
        vec3 color = mix(vec3(1.0, 0.8, 1.0-f), vec3(0.5*f, 0, 0), pow(a, 0.2)) * 3.;
        color += mix(vec3(0.8, 0.9, 1.0), vec3(0.1, 0.1, 0.2),  pow(b, 0.1)) * 0.75;
        color += mix(vec3(0.9, 0.8, 1.0), vec3(0.1, 0.2, 0.2),  pow(c, 0.1)) * 0.75;
        
        float scale = sin(0.1 * time) * 0.5 + 5.0;
        float distortion = resolution.y / resolution.x;

        vec2 position2 = (((gl_FragCoord.xy * 0.8 / resolution) ) * scale);
        position2.y *= distortion;

        float gradient = 0.0;
        vec3 color2 = vec3(0.0);
 
        float fade = 0.5;
        float z = 0.6;
 
        vec2 centered_coord = position2 - vec2(2.0,1.0);

        for (float i=1.0; i<=134.0; i++)
        {
                vec2 star_pos = vec2(sin(i) * 200.0, sin(i*i*i) * 300.0);
                float z = mod(i*i - 100.0*time, 512.0);
                float fade = (456.0 - z) /300.0;
                vec2 blob_coord = star_pos / z;
                gradient += ((fade / 1500.0) / pow(length(centered_coord - blob_coord ), 1.8)) * ( fade);
        }

        color2 = color * gradient;
        
        gl_FragColor = vec4( max( color * clamp(dd, 0.0, 1.0) , color2 ) , 1.0);
}
</script>

<!-- http://glsl.heroku.com/e#19689.0 -->
<script id='19689.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;



float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float sdFloor(vec3 p, vec3 b) {
  return length(max(abs(p)-b,0.0));
}

float sdCylinder( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

void main()
{


        vec2 coords = gl_FragCoord.xy / resolution;
        
        vec3 ray_dir = normalize( vec3( coords.x-sin(time*0.5)*0.1, coords.y - 0.5, -1.0 +sin(time*0.5)*0.1) );
        vec3 ray_orig = vec3((time*0.05)*cos(time*0.05)*20.0,5.0,100.0);
        float offs = 0.0;
        float j;
        for( float i = 0.0; i < 500.0;i += 1.0 ) {
                vec3 pos = vec3(ray_orig+ray_dir*offs);
                        
                vec3 c = vec3(100.0,100.0,100.0);
                vec3 q = mod(pos,c)-0.5*c;
                
                float dist = sdCylinder(q, vec3(0.0,0.0,5.0));
                
                dist = min(dist, sdFloor(q, vec3(50.0,1.0,50.0)));
                
                offs+=dist;
                j = i+(i*sin(time))/50.;
                if(abs(dist)<0.0001) break;
                
        }
        
        float c=j/50.0;
        gl_FragColor=vec4(vec3(c*cos(time),c*sin(time),c*sin(sqrt(time))), 8.0);
        
}
</script>

<!-- http://glsl.heroku.com/e#19528.0 -->
<script id='19528.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

// shorter version --novalis

uniform float time;
uniform vec2 resolution;

float distance1(vec2 p1, vec2 p2){
        return max(abs((p2-p1).x),abs((p2-p1).y));
}
void main(void) {
        vec2 p = gl_FragCoord.xy/resolution.xx*2.-vec2(1.,.5);
        gl_FragColor = distance1(p,vec2(0.0))*vec4(vec3((mod(.3/distance1(p,vec2(.0))+time*.1,.1)>cos(time+p.x)*0.05+0.05)^^(mod(atan(p.y,p.x)*7./22.+time*.1,.1)>sin(time+p.y)*0.05+0.05)),1.)*.4;
}
</script>

<!-- http://glsl.heroku.com/e#19698.3 -->
<script id='19698.3' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;



float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float sdFloor(vec3 p, vec3 b) {
  return length(max(abs(p)-b,0.0));
}

float sdCylinder( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

void main() {
        vec2 coords = gl_FragCoord.xy/resolution;

        vec3 ray_dir = normalize(vec3(coords.x-sin(time*0.5)*0.1, coords.y-.5, -1.+sin(time*.5)*.1));
        vec3 ray_orig = vec3(cos(time*.05)*50.,sin(time*.5)*50.-25.,100);
        float offs = 0.;
        float j;
        for(float i=0.; i<500.; i+=1.) {
                vec3 pos = vec3(ray_orig+ray_dir*offs);
                        
                vec3 c = vec3(100);
                vec3 q = mod(pos,c)-0.5*c;
                
                float dist = sdCylinder(q, vec3(0,0,5));
                
                dist = min(dist, sdFloor(q, vec3(10,0,50)));
                dist = min(dist, sdFloor(q, vec3(50,0,10)));
                
                offs+=dist;
                j = i+(i*sin(time))/50.;
                if(abs(dist)<1e-3) break;
        }
        
        float c=j/50.;
        gl_FragColor=vec4(vec3(c*pow(cos(time),2.),c*pow(sin(time),2.),c*sin(sqrt(time))), 8.0);
        
}
</script>

<!-- http://glsl.heroku.com/e#19454.0 -->
<script id='19454.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

#ifdef title 
Aurora borealis by guti
#endif
        
#ifdef author
guti
#endif
        
// modified version of http://glsl.heroku.com/e#1450.0
        
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform sampler2D backbuffer;

const float pi = 3.141516;

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
  return 2.2 * n_xyz;
}

vec3 surface3 ( vec3 coord ) {
        
        float frequency = 9.0;
        float n = 0.0;  
                
        float n1 =       abs( cnoise( coord * frequency ) );
        float n2 = 0.8  * abs( cnoise( coord * vec3(1.0, 1.0, abs(sin(coord.z) * 0.02)) * frequency ) );
        n += 1.0        * abs( cnoise( coord * frequency * 2.0 ) );
        
        return vec3(n1, n2, n);
}
        
void main( void ) {
        
        vec2 position = gl_FragCoord.xy / resolution.xy;
        
        vec3 c = vec3(0.0);
        c += vec3(surface3(vec3(position.x, 100.0, time * 0.05)));
        c = c - (1.0 - vec3(pow(sin(position.y * pi), 0.5)));
                
        gl_FragColor = vec4(c, 1.0);
}
</script>

<!-- http://glsl.heroku.com/e#14282.0 -->
<script id='14282.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main( void ) {

        vec2 position = gl_FragCoord.xy / resolution.y * 2.0 - vec2(resolution.x / resolution.y, 1.0);
        
        vec3 col = vec3(0, 0, 0);
                
        for (int i = 0; i < 7; ++i) {
                float mt = mod(time, 999.0) * 0.3 * (float(i) * 0.3);
                float t = mod(time * 0.4, 1111.0) * (float(i) + 2.0);
                float x2 = cos(t) * 0.7 + sin(mt) * 0.02;
                float y2 = sin(t) * 0.7 + cos(mt) * 0.02;
                float x = cos(t/0.3) * x2 + sin(t/0.3) * y2;
                //float y = sin(t/0.3) * x2 + cos(t/0.3) * y2;
                x = x2;
                float y = y2;
                vec2 d3 = position - vec2(x, y);
                
                float tt = t * (float(i) + 5.0) / 20.0 + d3.x * tan(t*1.5) + d3.y * tan(t*2.0);
                vec2 d = vec2(d3.x * cos(tt) + d3.y * sin(tt), d3.x * sin(tt) - d3.y * cos(tt));
                
                float rx = 0.7 - (abs(sin(t * 0.5)) / 2.0);
                float ry = 0.7 - (abs(tan(t * 100.5)) / 2.0);
                d.x *= rx;
                d.y *= ry;
                
                float d2 = dot(d, d);
                float a = abs(d2 - 0.03);

                float u = mod(time*2.0, 1111.0) * (float(i) * 0.1 + 2.0);
                col.r += 0.005 * sin(u) * sin(u) / (a + 0.00001);
                if (d2 < 0.03)
                        col.r +=  0.3 * sin(u) * sin(u);

                u = mod(time*1.9, 1111.0) * (float(i) * 0.1 + 2.0);
                col.g += 0.005 * cos(u) * cos(u) / (a + 0.00001);
                if (d2 < 0.03)
                        col.g +=  0.3 * sin(u) * sin(u);

                u = mod(time*1.8, 1111.0) * (float(i) * 0.1 + 2.0);
                col.b += 0.005 * sin(u+0.787) * sin(u+0.787) / (a + 0.00001);
                if (d2 < 0.03)
                        col.b +=  0.3 * sin(u) * sin(u);
        }
        gl_FragColor = vec4(col, 1.0);
}
</script>

<!-- http://glsl.heroku.com/e#14373.1 -->
<script id='14373.1' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// srtuss, 2014
// Ported from www.shadertoy.com

#define PI 3.1415926535897932384626433832795

#define ITER 12

vec2 rotate(vec2 p, float a)
        {
        return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
        }

vec2 circuit(vec2 p)
        {
        p = fract(p);
        float r = 0.123;
        float v = 0.0, g = 0.0;
        float test = 0.0;
        r = fract(r * 9184.928);
        float cp, d;
        
        d = p.x;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);
        d = p.y;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);
        d = p.x - 1.0;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);
        d = p.y - 1.0;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 280.0);
        
        for(int i = 0; i < ITER; i ++)
                {
                cp = 0.5 + (r - 0.5) * 0.9;
                d = p.x - cp;
                g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);
                if(d > 0.0)
                        {
                        r = fract(r * 4829.013);
                        p.x = (p.x - cp) / (1.0 - cp);
                        v += 1.0;
                        test = r;
                        }
                else
                        {
                        r = fract(r * 1239.528);
                        p.x = p.x / cp;
                        test = r;
                        }
                p = p.yx;
                }
        v /= float(ITER);
        return vec2(v, g);
        }

float box(vec2 p, vec2 b, float r)
        {
        return length(max(abs(p) - b, 0.0)) - r;
        }

float rand(float p)
        {
        return fract(sin(p * 591.32) * 43758.5357);
        }

float rand2(vec2 p)
        {
        return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5357);
        }

vec2 rand2(float p)
        {
        return fract(vec2(sin(p * 591.32), cos(p * 391.32)));
        }

vec3 sky(vec3 rd, float t)
        {
        float u = atan(rd.z, rd.x) / PI / 2.0;
        float v = rd.y / length(rd.xz);
        float fg = exp(-0.04 * abs(v));
        vec2 ca = circuit(vec2(u, (v - t * 3.0) * 0.03));
        vec2 cb = circuit(vec2(-u, (v - t * 4.0) * 0.06));
        float c = (ca.x - ca.y * 0.2) + cb.y * 0.7;
        vec3 glow = pow(vec3(c), vec3(0.18, 0.4, 1.0) * 3.0);
        vec2 cr = vec2(u, (v - t * 5.0) * 0.03);
        float crFr = fract(cr.y);
        float r = smoothstep(0.8, 0.82, abs(crFr * 2.0 - 1.0));
        float vo = 0.0, gl = 0.0;
        for(int i = 0; i < 6; i ++)
                {
                float id = float(i);
                vec2 off = rand2(id);
                vec2 pp = vec2(fract(cr.x * 5.0 + off.x + t * 8.0 * (0.5 + rand(id))) - 0.5, fract(cr.y * 12.0 + off.y * 0.2) - 0.5);
                float di = box(pp, vec2(0.2, 0.01), 0.02);
                vo += smoothstep(0.999, 1.0, 1.0 - di);
                gl += exp(max(di, 0.0) * -60.0);
                }
        vo = pow(vo * 0.4, 2.0);
        vec3 qds = vec3(1.0);
        vec3 col = mix(glow, qds, clamp(vo, 0.0, 1.0)) + vec3(0.0, 0.5, 1.0) * gl * 0.5;
        return col + (1.0 - fg);
        }

vec3 colorset(float v)
        {
        return pow(vec3(v), vec3(0.2, 0.4, 1.0) * 2.0);
        }



vec3 pixel(vec2 uv)
        {
        uv /= resolution.xy;
        uv = uv * 2.0 - 1.0;
        uv.x *= resolution.x / resolution.y;
        vec3 ro = vec3(0.0, 0.0, -0.0);
        vec3 rd = normalize(vec3(uv, 1.6));
        float t = time* 0.5;
        rd.yz = rotate(rd.yz, sin(t) * 0.9 + PI * 0.5);
        rd.xz = rotate(rd.xz, t);
        rd.xy = rotate(rd.xy, cos(t) * 0.2);
        vec3 col = sky(rd, t * 0.7);
        return pow(col, vec3(1.5)) * 1.3;
        }



void main()
        {
        vec2 uv = gl_FragCoord.xy;
        vec3 col;
        vec2 h = vec2(0.5, 0.0);
        uv += rand2(time) * 6.0;
        col = pixel(uv);
        col += pixel(uv + h.xy);
        col += pixel(uv + h.yx);
        col += pixel(uv + h.xx);
        col /= 4.0;
        gl_FragColor = vec4(col, 1.0);
        }
</script>

<!-- http://glsl.heroku.com/e#19512.0 -->
<script id='19512.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

//more hexagon stuff :D

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
varying vec2 surfacePosition;

const float pi=3.14159265359;

vec2 hexify(vec2 p,float hexCount){
        p*=hexCount;
        vec3 p2=floor(vec3(p.x/0.86602540378,p.y+0.57735026919*p.x,p.y-0.57735026919*p.x));
        float y=floor((p2.y+p2.z)/3.0);
        float x=floor((p2.x+(1.0-mod(y,2.0)))/2.0);
        return vec2(x,y)/hexCount;
}

void main( void ) {
        vec2 p=gl_FragCoord.xy/resolution.xy-0.5;
        float l=length(p);
        p.x*=resolution.x/resolution.y;
        p=vec2(1.0/length(p)+time,fract((atan(p.y,p.x)+pi/2.0)/pi+0.5));
        p.y=1.0+8.25*abs(p.y-0.5);
        p=hexify(p,8.0);
        gl_FragColor = pow(l,0.5)*vec4(sin(p.x)*cos(p.y-time*sin(p.y-p.x)),sin(p.y*(1.0-p.x))+cos(sin(p.x+time)+p.x*p.y),cos(sin(p.y+time-sin(p.x))),1);
}
</script>

<!-- http://glsl.heroku.com/e#19150.0 -->
<script id='19150.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float gc=fract(time*3.2/90.),
gb=fract(gc*2.),
PI=3.14159;
vec3 ff(vec2 p){
    vec2 q=vec2(sin(.08*p.x),4.*p.y);
    vec3 c=vec3(0);
    for(float i=0.;i<10.;i++)
      c+=(1.+sin(i*sin(time)+vec3(0.,1.3,2.2)))*.2/length(q-vec2(sin(i),12.*sin(.3*time+i)));
    return c+vec3(mix(mod(floor(p.x*.2)+floor(p.y*2.2),2.),.2,gc));
}
vec3 ft(vec3 o,vec3 d){
    d.y*=.65+.1*sin(.5*time);
    float D=1./(d.y*d.y+d.z*d.z),
          a=(o.y*d.y+o.z*d.z)*D,
          b=(o.y*o.y+o.z*o.z-36.)*D,
          t=-a-sqrt(a*a-b);
    o+=t*d;
    return ff(vec2(o.x,atan(o.y,o.z)))*(1.+.01*t);
}
void main(){
    vec2 p=(2.*gl_FragCoord.xy-resolution)/resolution.y,
         q=2.*gl_FragCoord.xy/resolution-1.;
    vec3 cp=vec3(-time*20.+1.,1.6*sin(time*1.2),2.+2.*cos(time*.3)),
         ct=cp+vec3(1.,.3*cos(time),-.2),
         cd=normalize(ct-cp),
         cr=normalize(cross(cd,vec3(.5*cos(.3*time),0.,1.))),
         cu=cross(cr,cd),
         rd=normalize(2.*cd+cr*p.x+cu*p.y),
         c=ft(cp,rd)*
           min(1.,1.8-dot(q,q))*(.9+.1*sin(3.*sin(gc)*gl_FragCoord.y));
    gl_FragColor=vec4(c,1);
}
</script>

<!-- http://glsl.heroku.com/e#19136.0 -->
<script id='19136.0' type='x-shader/x-fragment'>
precision mediump float;

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

vec3 sind(vec2 pos, float amp, float freq, float wavw, float pown, vec3 col){

        float xd = pow(wavw - (abs(pos.y - sin(pos.x * freq) * amp)),pown);
        
        return xd * col;
        
}

float d(vec2 pos, float wavw){
        return wavw - abs(pos.y - pos.x);
}

void main( void ) {

        vec2 p = (gl_FragCoord.xy * 2. - resolution) / max(resolution.x, resolution.y);

        vec3 col =      sind(vec2(time*.3 + p.x, p.y), .1, 10. , 1.01, 30., vec3(.6,1.,1.));
        col +=          sind(vec2(time*.4+ p.x, p.y),  .1, 6.  , 1.01, 30., vec3(.6,.3,1.));

        col +=          sind(vec2(time*.4+ p.y, p.y),  .2, 20.  , 1.001, 30., vec3(.2,.7,.5));
        col +=          sind(vec2(time*.4+ p.x, p.x),  1., 20.  , 1.001, 30., vec3(.2,.7,.5));


        col +=          sind(vec2(time*.3 + pow(p.x + 1., .1), p.y),  .2, 6.  , 1.01, 30., vec3(.1,1.,.7));
        col +=  sind(vec2(time*.3 + p.x, p.y + p.x), .3, 10. , 1.01, 30., vec3(.6,1.,1.));

        

        col +=          sind(vec2(time*.2 + p.y, mod(time * .2, p.x) * p.x), .3, 10. , 1.01, 30., vec3(1.,.5,1.));
        col +=          sind(vec2(time*.2+ p.y, p.x),  .2, 6.  , 1.01, 30., vec3(1.,1.,.2));

        col +=          sind(vec2(p.x, p.y)          , 1., 2., 1.01, 20., vec3(.6,1.,.8));
        col +=          sind(vec2(p.y, p.x)          , 1., 2., 1.01, 20., vec3(.6,1.,.8));
        
        gl_FragColor = vec4(vec3(col), 1.);

}
</script>

<!-- http://glsl.heroku.com/e#18981.0 -->
<script id='18981.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main(void)
{
        vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;
        uv.x *=  resolution.x / resolution.y;
        
    // background        
        vec3 color = vec3(0.8 + 0.4*uv.y);

    // bubbles  
        for( int i=0; i<40; i++ )
        {
        // bubble seeds
                float pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;
                float siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );
                float pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;
                
        // buble size, position and color
                float rad = 0.1 + 0.5*siz;
                vec2  pos = vec2( pox + siz*sin(time+float(i)), -1.0-rad + (2.0+2.0*rad)*mod(pha+0.4*time*(0.2+0.8*siz),1.0));
                float dis = length( uv - pos );
                vec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));
                //    col+= 8.0*smoothstep( rad*0.95, rad, dis );
                
        // render
                float f = length(uv-pos)/rad;
                f = sqrt(clamp(1.0-f*f,0.0,1.0));
                color -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;
        }

    // vigneting        
        color *= sqrt(1.8-0.7*length(uv));

        gl_FragColor = vec4(color,1.0);
}
</script>

<!-- http://glsl.heroku.com/e#18873.0 -->
<script id='18873.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.1415926535897932384626433832795

uniform float time;
uniform vec2 resolution;

const float scale = 1.0;

varying vec2 surfacePosition;

float band(vec2 pos, float amplitude, float frequency) {
        float wave = scale * amplitude * sin(1.0 * PI * frequency * pos.x + time) / 3.0;
        float light = clamp(amplitude * frequency * 0.02, 0.001 + 0.001 / scale, 5.0) * scale / abs(wave - pos.y);
        return light;
}

void main( void ) {
        

        vec3 color = vec3(1.1+cos(time), sin(time)+1.2, sin(3.14*time));
        vec2 pos = surfacePosition;//(gl_FragCoord.xy / resolution.xy);
        //pos.y += - 0.5 - position;
        
        // +pk
        float spectrum = 0.0;
        const float lim = 28.;
        #define time time*0.037 + pos.x*100.
        spectrum += band(pos, cos(sin(31.4*time)), sin(cos(31.4*time)));
        
        gl_FragColor = vec4(color * spectrum, spectrum);
        
}
</script>

<!-- http://glsl.heroku.com/e#18770.0 -->
<script id='18770.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float rand(int seed, float ray) {
        return mod(sin(float(seed)*363.5346+ray*674.2454)*6743.4365, 1.0);
}

void main( void ) {
        float pi = 3.14159265359;
        vec2 position = ( gl_FragCoord.xy / resolution.xy ) - mouse;
        position.y *= resolution.y/resolution.x;
        float ang = atan(position.y, position.x);
        float dist = length(position);
        gl_FragColor.rgb = vec3(0.3, 0.5, 0.7) * (pow(dist, -1.0) * 0.05);
        for (float ray = 0.0; ray < 60.0; ray += 1.0) {
                //float rayang = rand(5234, ray)*6.2+time*5.0*(rand(2534, ray)-rand(3545, ray));
                float rayang = rand(5234, ray)*6.2+(mouse.x+time*0.01)*10.0*(rand(2546, ray)-rand(5785, ray))-mouse.y*10.0*(rand(3545, ray)-rand(5467, ray));
                rayang = mod(rayang, pi*2.0);
                if (rayang < ang - pi) {rayang += pi*2.0;}
                if (rayang > ang + pi) {rayang -= pi*2.0;}
                float brite = .3 - abs(ang - rayang);
                brite -= dist * 0.2;
                if (brite > 0.0) {
                        gl_FragColor.rgb += vec3(0.2+0.4*rand(8644, ray), 0.4+0.4*rand(4567, ray), 0.5+0.4*rand(7354, ray)) * brite;
                }
        }
        gl_FragColor.a = 1.0;
}
</script>

<!-- http://glsl.heroku.com/e#18760.0 -->
<script id='18760.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float PI  = 4.0*atan(1.0);

vec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );
vec3 cameraPos;
vec3 sunColour = vec3(1.0, .75, .6);
const mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);
float gTime = 0.0;

//--------------------------------------------------------------------------
// Noise functions...
float Hash( float n )
{
    return fract(sin(n)*0.002);
}

//--------------------------------------------------------------------------
float Hash(vec2 p)
{
        return fract(sin(dot(p, vec2(0.002, 0.0233))) * 0.0003);
}

//--------------------------------------------------------------------------
float Noise( in vec2 x )
{
    vec2 p = floor(x);
    vec2 f = fract(x);
    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0;
    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),
                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);
    return res;
}

vec2 Voronoi( in vec2 x )
{
        vec2 p = floor( x );
        vec2 f = fract( x );
        float res=100.0,id;
        for( int j=-1; j<=1; j++ )
        for( int i=-1; i<=1; i++ )
        {
                vec2 b = vec2( float(i), float(j) );
                vec2 r = vec2( b ) - f  + Hash( p + b );
                float d = dot(r,r);
                if( d < res )
                {
                        res = d;
                        id  = Hash(p+b);
                }                       
    }
        return vec2(max(.4-sqrt(res), 0.0),id);
}


//--------------------------------------------------------------------------
vec2 Terrain( in vec2 p)
{
        float type = 0.0;
        vec2 pos = p*0.003;
        float w = 50.0;
        float f = .0;
        for (int i = 0; i < 3; i++)
        {
                f += Noise(pos) * w;
                w = w * 0.62;
                pos *= 2.5;
        }

        return vec2(f, type);
}

//--------------------------------------------------------------------------
vec2 Map(in vec3 p)
{
        vec2 h = Terrain(p.xz);
    return vec2(p.y - h.x, h.y);
}

//--------------------------------------------------------------------------
float FractalNoise(in vec2 xy)
{
        float w = .7;
        float f = 0.0;

        for (int i = 0; i < 3; i++)
        {
                f += Noise(xy) * w;
                w = w*0.6;
                xy = 2.0 * xy;
        }
        return f;
}

//--------------------------------------------------------------------------
// Grab all sky information for a given ray from camera
vec3 GetSky(in vec3 rd)
{
        float sunAmount = max( dot( rd, sunLight), 0.0 );
        float v = pow(1.0-max(rd.y,0.0),6.);
        vec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);
        sky = sky + sunColour * sunAmount * sunAmount * .25;
        sky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);
        return clamp(sky, 0.0, 1.0);
}

//--------------------------------------------------------------------------
// Merge grass into the sky background for correct fog colouring...
vec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)
{
        float fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);
        return mix( rgb, GetSky(dir), fogAmount );
}

//--------------------------------------------------------------------------
vec3 DE(vec3 p)
{
        float base = Terrain(p.xz).x - 1.9;
        float height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;
        //p.y += height;
        float y = p.y - base-height;
        y = y*y;
        vec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*12.3)*.12+vec2(sin(time*2.3+1.5*p.z),sin(time*3.6+1.5*p.x))*y*.5));
        float f = ret.x * .6 + y * .58;
        return vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);
}

//--------------------------------------------------------------------------
// eiffie's code for calculating the aperture size for a given distance...
float CircleOfConfusion(float t)
{
        return max(t * .04, (2.0 / resolution.y) * (1.0+t));
}

//--------------------------------------------------------------------------
float Linstep(float a, float b, float t)
{
        return clamp((t-a)/(b-a),0.,1.);
}

//--------------------------------------------------------------------------
vec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)
{
        float d = 0.0;
        float f;
        // Only calculate cCoC once is enough here...
        float rCoC = CircleOfConfusion(dist*.3);
        float alpha = 0.0;
        
        vec4 col = vec4(mat*0.15, 0.0);

        for (int i = 0; i < 15; i++)
        {
                if (col.w > .99) break;
                vec3 p = rO + rD * d;
                
                vec3 ret = DE(p);
                ret.x += .5 * rCoC;

                if (ret.x < rCoC)
                {
                        alpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density
                        f = clamp(ret.y, 0.0, 1.0);
                        // Mix material with white tips for grass...
                        vec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;
                        col += vec4(gra * alpha, alpha);
                }
                d += max(ret.x * .7, .1);
        }
        if(col.w < .2)
                col.xyz = vec3(0.1, .15, 0.05);
        return col.xyz;
}

//--------------------------------------------------------------------------
// Calculate sun light...
void DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)
{
        float h = dot(sunLight,normal);
        mat = mat * sunColour*(max(h, 0.0)+.2);
}

//--------------------------------------------------------------------------
vec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)
{
        vec3 mat;
        if (type == 0.0)
        {
                // Random colour...
                mat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));
                // Random shadows...
                float t = FractalNoise(pos.xz * .1)+.5;
                // Do grass blade tracing...
                mat = GrassBlades(pos, dir, mat, dis) * t;
                DoLighting(mat, pos, normal,dir, dis);
        }
        mat = ApplyFog(mat, dis, dir);
        return mat;
}

//--------------------------------------------------------------------------
// Home in on the surface by dividing by two and split...
float BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)
{
        float halfwayT = 0.0;
        for (int n = 0; n < 5; n++)
        {
                halfwayT = (oldT + t ) * .5;
                if (Map(rO + halfwayT*rD).x < .05)
                {
                        t = halfwayT;
                }else
                {
                        oldT = halfwayT;
                }
        }
        return t;
}

//--------------------------------------------------------------------------
bool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )
{
    float t = 5.;
        float oldT = 0.0;
        float delta = 0.;
        vec2 h = vec2(1.0, 1.0);
        bool hit = false;
        for( int j=0; j < 80; j++ )
        {
            vec3 p = rO + t*rD;
                if (p.y < 105.0 && !hit)
                {
                        h = Map(p); // ...Get this position's height mapping.
        
                        // Are we inside, and close enough to fudge a hit?...
                        if( h.x < 0.05)
                        {
                                // Yes! So home in on height map...
                                resT = BinarySubdivision(rO, rD, t, oldT);
                                type = h.y;
                                hit = true;
                        }else
                        {
                                // Delta ray advance - a fudge between the height returned
                                // and the distance already travelled.
                                // Compromise between speed and accuracy...
                                delta = max(0.04, 0.35*h.x) + (t*0.04);
                                oldT = t;
                                t += delta;
                        }
                }
        }

        return hit;
}

//--------------------------------------------------------------------------
vec3 CameraPath( float t )
{
        //t = time + t;
    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );
        return vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);
} 

//--------------------------------------------------------------------------
vec3 PostEffects(vec3 rgb, vec2 xy)
{
        // Gamma first...
        rgb = pow(rgb, vec3(0.45));
        
        // Then...
        #define CONTRAST 1.1
        #define SATURATION 1.3
        #define BRIGHTNESS 1.3
        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);
        // Vignette...
        rgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );  
        return rgb;
}

//--------------------------------------------------------------------------
void main(void)
{
        float m = (mouse.x/resolution.x)*300.0;
        float gTime = (time*5.0+m+2352.0)*.006;
    vec2 xy = gl_FragCoord.xy / resolution.xy;
        vec2 uv = (-1.0 + 2.0 * xy) * vec2(resolution.x/resolution.y,1.0);
        vec3 camTar;
        
        if (xy.y < .13 || xy.y >= .87)
        {
                // Top and bottom cine-crop - what a waste! :)
                gl_FragColor=vec4(vec4(0.0));
                return;
        }

        #ifdef STEREO
        float isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);
        #endif

        cameraPos = CameraPath(gTime + 0.0);
        camTar   = CameraPath(gTime + .009);
        cameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;
        camTar.y = cameraPos.y;
        
        float roll = .4*sin(gTime+.5);
        vec3 cw = normalize(camTar-cameraPos);
        vec3 cp = vec3(sin(roll), cos(roll),0.0);
        vec3 cu = cross(cw,cp);
        vec3 cv = cross(cu,cw);
        vec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);
        mat3 camMat = mat3(cu, cv, cw);

        #ifdef STEREO
        cameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good
        #endif

        vec3 col;
        float distance;
        float type;
        if( !Scene(cameraPos, dir, distance, type) )
        {
                // Missed scene, now just get the sky...
                col = GetSky(dir);
        }
        else
        {
                // Get world coordinate of landscape...
                vec3 pos = cameraPos + distance * dir;
                // Get normal from sampling the high definition height map
                // Use the distance to sample larger gaps to help stop aliasing...
                vec2 p = vec2(0.1, 0.0);
                vec3 nor        = vec3(0.0,             Terrain(pos.xz).x, 0.0);
                vec3 v2         = nor-vec3(p.x, Terrain(pos.xz+p).x, 0.0);
                vec3 v3         = nor-vec3(0.0, Terrain(pos.xz-p.yx).x, -p.x);
                nor = cross(v2, v3);
                nor = normalize(nor);

                // Get the colour using all available data...
                col = TerrainColour(pos, dir, nor, distance, type);
        }
        
        // bri is the brightness of sun at the centre of the camera direction.
        // Yeah, the lens flares is not exactly subtle, but it was good fun making it.
        float bri = dot(cw, sunLight)*.75;
        if (bri > 0.0)
        {
                vec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );
                vec2 uvT = uv-sunPos;
                uvT = uvT*(length(uvT));
                bri = pow(bri, 6.0)*.8;

                // glare = the red shifted blob...
                float glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;
                // glare2 is the yellow ring...
                float glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);
                uvT = mix (uvT, uv, -2.3);
                // glare3 is a purple splodge...
                float glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);

                col += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;
                col += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;
                col += bri * sunColour * pow(glare3, 2.0)*3.0;
        }
        col = PostEffects(col, xy);     
        
        #ifdef STEREO   
        col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );  
        #endif
        
        gl_FragColor=vec4(col,1.0);
}

//--------------------------------------------------------------------------
</script>

<!-- http://glslsandbox.com/e#18602.4 -->
<script id='18602.4' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

// xray by Jaksa

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float sphere(vec3 p, vec3 o, float r) {
        return distance(p,o) - r;
}

float cube(vec3 p, vec3 o, float side) {
        vec3 d = abs(p - o);
        return max(d.x, max(d.y, d.z)) - side;
}

float map(vec3 p) {
        p.z += time*10.0;
        p.x += -cos(time/4.)*10.;
        p.y += 30.*sin(time/10.)+10.;
        p.xz = mod(p.xz+10., 20.0)-10.;
        float d = p.y + 30.;
//      d = min(d, sphere(p, vec3(0,0,6), 3.0));
//      d = min(d, sphere(p, vec3(1,5,10), 2.0));
        d = min(d, cube(p, vec3(2,-10,7), 4.0));
        d = min(d, cube(p, vec3(2,10,7), 2.0));
        d = min(d, cube(p, vec3(2,30,7), 1.0));
        return d;
}

vec3 grad(vec3 p) {
        vec2 d = vec2(0.01,0.0);
        
        return (map(p) - vec3(map(p + d.xyy), map(p + d.yxy), map(p+d.yyx)))/d.x;
}

void main( void ) {
        vec2 pix = (2.*gl_FragCoord.xy/resolution.y-1.);
        vec3 cam = vec3(0,10.0,0);
        vec3 camDir = normalize(vec3(sin(time/4.)*.2,0,1));
        vec3 screenCenter = cam + camDir;
        vec3 up = vec3(0,1,0);
        vec3 u = -normalize(cross(up, camDir));
        vec3 v = normalize(cross(u, camDir));
        vec3 uv = u * pix.x + v * pix.y;
        vec3 p = vec3(uv+screenCenter); 
        vec3 dir = normalize(p-cam);

        float delta = 0.001;
        float d = 0.0;
        float dist = 0.0;
        
        float volume = 0.0;
        float angle = 0.0;
        
        for (int i = 0; i < 128; i++) {
                d = map(p);
                volume += max(-clamp(d, -.01, .01), 0.0);
                dist += max(max(0.0, d), .2);
                if (dist > 500.) break;
                p = dir*dist;
        }
        
        angle = dot(dir, grad(p));
        float c = log(1.0 + volume)/(1.0 + log(1.0 + volume));
        c *= 2.6;
        gl_FragColor = vec4(c * vec3(.6*c,.6*c,1.0), 1.0 );
}
</script>

<!-- http://glslsandbox.com/e#18602.4 -->
<script id='18602.4t' type='x-shader/x-fragment'>
// slightly modified to change the color to green
#ifdef GL_ES
precision mediump float;
#endif

// xray by Jaksa

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

float sphere(vec3 p, vec3 o, float r) {
        return distance(p,o) - r;
}

float cube(vec3 p, vec3 o, float side) {
        vec3 d = abs(p - o);
        return max(d.x, max(d.y, d.z)) - side;
}

float map(vec3 p) {
        p.z += time*10.0;
        p.x += -cos(time/4.)*10.;
        p.y += 30.*sin(time/10.)+10.;
        p.xz = mod(p.xz+10., 20.0)-10.;
        float d = p.y + 30.;
//      d = min(d, sphere(p, vec3(0,0,6), 3.0));
//      d = min(d, sphere(p, vec3(1,5,10), 2.0));
        d = min(d, cube(p, vec3(2,-10,7), 4.0));
        d = min(d, cube(p, vec3(2,10,7), 2.0));
        d = min(d, cube(p, vec3(2,30,7), 1.0));
        return d;
}

vec3 grad(vec3 p) {
        vec2 d = vec2(0.01,0.0);
        
        return (map(p) - vec3(map(p + d.xyy), map(p + d.yxy), map(p+d.yyx)))/d.x;
}

void main( void ) {
        vec2 pix = (2.*gl_FragCoord.xy/resolution.y-1.);
        vec3 cam = vec3(0,10.0,0);
        vec3 camDir = normalize(vec3(sin(time/4.)*.2,0,1));
        vec3 screenCenter = cam + camDir;
        vec3 up = vec3(0,1,0);
        vec3 u = -normalize(cross(up, camDir));
        vec3 v = normalize(cross(u, camDir));
        vec3 uv = u * pix.x + v * pix.y;
        vec3 p = vec3(uv+screenCenter); 
        vec3 dir = normalize(p-cam);

        float delta = 0.001;
        float d = 0.0;
        float dist = 0.0;
        
        float volume = 0.0;
        float angle = 0.0;
        
        for (int i = 0; i < 128; i++) {
                d = map(p);
                volume += max(-clamp(d, -.01, .01), 0.0);
                dist += max(max(0.0, d), .2);
                if (dist > 500.) break;
                p = dir*dist;
        }
        
        angle = dot(dir, grad(p));
        float c = log(1.0 + volume)/(1.0 + log(1.0 + volume));
        c *= 2.6;
        gl_FragColor = vec4(c * vec3(.6*c,1.0,.6*c), 1.0 );
}
</script>

<!-- http://glslsandbox.com/e#18142.0 -->
<script id='18142.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// rotate position around axis
vec2 rotate(vec2 p, float a)
{
        return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
}

// 1D random numbers
float rand(float n)
{
    return fract(sin(n) * 43758.5453123);
}

// 2D random numbers
vec2 rand2(in vec2 p)
{
        return fract(vec2(sin(p.x * 591.32 + p.y * 154.077 + time), cos(p.x * 391.32 + p.y * 49.077 + time)));
}

// 1D noise
float noise1(float p)
{
        float fl = floor(p);
        float fc = fract(p);
        return mix(rand(fl), rand(fl + 1.0), fc);
}

// voronoi distance noise, based on iq's articles
float voronoi(in vec2 x)
{
        vec2 p = floor(x);
        vec2 f = fract(x);
        
        vec2 res = vec2(8.0);
        for(int j = -1; j <= 1; j ++)
        {
                for(int i = -1; i <= 1; i ++)
                {
                        vec2 b = vec2(i, j);
                        vec2 r = vec2(b) - f + rand2(p + b);
                        
                        // chebyshev distance, one of many ways to do this
                        float d = max(abs(r.x), abs(r.y));
                        
                        if(d < res.x)
                        {
                                res.y = res.x;
                                res.x = d;
                        }
                        else if(d < res.y)
                        {
                                res.y = d;
                        }
                }
        }
        return res.y - res.x;
}


float flicker = noise1(time * 1.0) * 0.8 + 0.;

void main(void)
{
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        uv = (uv - 0.5) * 2.0;
        vec2 suv = uv;
        uv.x *= resolution.x / resolution.y;
        
        
        float v = 0.0;
        
        // that looks highly interesting:
        //v = 1.0 - length(uv) * 1.3;
        
        
        // a bit of camera movement
        //uv *= 0.6 + sin(time * 0.1) * 0.4;
        uv = rotate(uv, sin(0.0 * 0.3) * 1.0);
        //uv += time * 0.4;
        
        
        // add some noise octaves
        float a = 0.6, f = 1.0;
        
        for(int i = 0; i < 3; i ++) // 4 octaves also look nice, its getting a bit slow though
        {       
                float v1 = voronoi(uv * f + 5.0);
                float v2 = 0.0;
                
                // make the moving electrons-effect for higher octaves
                if(i > 0)
                {
                        // of course everything based on voronoi
                        v2 = voronoi(uv * f * 0.5 + 50.0 + time);
                        
                        float va = 0.0, vb = 0.0;
                        va = 1.0 - smoothstep(0.0, 0.1, v1);
                        vb = 1.0 - smoothstep(0.0, 0.08, v2);
                        v += a * pow(va * (0.5 + vb), 2.0);
                }
                
                // make sharp edges
                v1 = 1.0 - smoothstep(0.0, 0.3, v1);
                
                // noise is used as intensity map
                v2 = a * (noise1(v1 * 5.5 + 0.1));
                
                // octave 0's intensity changes a bit
                if(i == 0)
                        v += v2 * flicker;
                else
                        v += v2;
                
                f *= 3.0;
                a *= 0.7;
        }

        // slight vignetting
        v *= exp(-0.6 * length(suv)) * 1.2;
        
        // use texture channel0 for color? why not.
        //vec3 cexp = texture2D(iChannel0, uv * 0.001).xyz * 3.0 + texture2D(iChannel0, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);
        
        // old blueish color set
        vec3 cexp = vec3(3.0, 2.0, 4.0);
                cexp *= 1.3;

        vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;
        
        gl_FragColor = vec4(col, 1.0);
}
</script>

<!-- http://glslsandbox.com/e#17945.0 -->
<script id='17945.0' type='x-shader/x-fragment'>
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

// srtuss, 2014
// Ported from www.shadertoy.com

#define PI 3.1415926535897932384626433832795

#define ITER 20

vec2 rotate(vec2 p, float a)
        {
        return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));
        }

vec2 circuit(vec2 p)
        {
        p = fract(p);
        float r = 0.223;
        float v = 0.0, g = 0.0;
        float test = 0.0;
        r = fract(r * 9184.928);
        float cp, d;
        
        d = p.x;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);
        d = p.y;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);
        d = p.x - 1.0;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);
        d = p.y - 1.0;
        g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);
        
        for(int i = 0; i < ITER; i ++)
                {
                cp = 0.5 + (r - 0.5) * 0.9;
                d = p.x - cp;
                g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 160.0);
                if(d > 0.0)
                        {
                        r = fract(r * 4829.013);
                        p.x = (p.x - cp) / (1.0 - cp);
                        v += 1.0;
                        test = r;
                        }
                else
                        {
                        r = fract(r * 1239.528);
                        p.x = p.x / cp;
                        test = r;
                        }
                p = p.yx;
                }
        v /= float(ITER);
        return vec2(v, g);
        }

float box(vec2 p, vec2 b, float r)
        {
        return length(max(abs(p) - b, 0.0)) -r ;
        }

float rand(float p)
        {
        return fract(sin(p * 591.32) * 43758.5357);
        }

float rand2(vec2 p)
        {
        return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5357);
        }

vec2 rand2(float p)
        {
        return fract(vec2(sin(p * 591.32), cos(p * 391.32)));
        }

vec3 sky(vec3 rd, float t)
        {
        float u = atan(rd.z, rd.x) / PI / 2.0;
        float v = rd.y / length(rd.xz);
        float fg = exp(-0.04 * abs(v));
        vec2 ca = circuit(vec2(u, (v - t * 3.0) * 0.03));
        vec2 cb = circuit(vec2(-u, (v - t * 4.0) * 0.06));
        float c = (ca.x - ca.y * 0.2) + cb.y * 0.7;
        vec3 glow = pow(vec3(c), vec3(0.9, 0.5, .3) * 2.0);
        vec2 cr = vec2(u, (v - t * 5.0) * 0.03);
        float crFr = fract(cr.y);
        float r = smoothstep(1.8, 0.82, abs(crFr * 2.0 - 1.0));
        float vo = 0.0, gl = 0.0;
        for(int i = 0; i < 6; i ++)
                {
                float id = float(i);
                vec2 off = rand2(id);
                vec2 pp = vec2(fract(cr.x * 5.0 + off.x + t * 8.0 * (0.5 + rand(id))) - 0.5, fract(cr.y * 12.0 + off.y * 0.2) - 0.5);
                float di = box(pp, vec2(0.2, 0.01), 0.02);
                vo += smoothstep(0.999, 1.0, 1.0 - di);
                gl += exp(max(di, 0.0) * -16.0);
                }
        vo = pow(vo * 0.4, 2.0);
        vec3 qds = vec3(1.0);
        vec3 col = mix(glow, qds, clamp(vo, 0.0, 1.0)) + vec3(0.05, 0.05, 0.05) * gl * 0.5;
        return col + (1.0 - fg);
        }

vec3 colorset(float v)
        {
        return pow(vec3(v), vec3(0.4, 0.4, 0.4) * 10.0);
        }



vec3 pixel(vec2 uv)
        {
        uv /= resolution.xy;
        uv = uv * 2.0 - 1.0;
        uv.x *= resolution.x / resolution.y;
        vec3 ro = vec3(0.0, 0.0, -0.0);
        vec3 rd = normalize(vec3(uv, 1.6));
        float t = time* 1.25;
        float down = PI / 2.0;
        rd.yz = rotate(rd.yz, 0.0);
        rd.xz = rotate(rd.xz, down);
        rd.xy = rotate(rd.xy, down);
        vec3 col = sky(rd, t);
        return pow(col, vec3(1.9)) * 1.3;
        }



void main()
        {
        vec2 uv = gl_FragCoord.xy;
        vec3 col;
        vec2 h = vec2(0.0, 0.0);
        col = pixel(uv);
        col += pixel(uv + h.xy);
        col += pixel(uv + h.yx);
        col += pixel(uv + h.xx);
        col /= 4.0;
        gl_FragColor = vec4(col, 1.0);
        gl_FragColor.b *= 0.36;
        gl_FragColor.g *= 0.36;
        gl_FragColor.r *= 0.1;
                
        }
</script>

